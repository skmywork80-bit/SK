<!DOCTYPE html>
<html lang="bn">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>SK Road Guard (Simple)</title>
<style>
  html,body{margin:0;height:100%;background:linear-gradient(#081226,#02030a);font-family:system-ui,Arial,sans-serif;color:#fff;overflow:hidden}
  canvas{display:block}
  #ui{position:fixed;left:12px;top:12px;z-index:10}
  #score{background:rgba(255,255,255,0.03);padding:8px 12px;border-radius:10px;font-weight:800}
  #hint{position:fixed;left:12px;bottom:12px;background:rgba(0,0,0,0.25);padding:8px 12px;border-radius:10px;font-size:13px}
  button{position:fixed;right:12px;top:12px;padding:8px 12px;border-radius:8px;border:none;background:#007bff;color:#fff;font-weight:700}
</style>
</head>
<body>
<div id="ui"><div id="score">Score: 0</div></div>
<button id="restart">Restart</button>
<div id="hint">Tap/Click on <strong>SK</strong> when a teacher is close to hit. (Touch & Mouse supported)</div>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
addEventListener('resize', resize); resize();

const scoreEl = document.getElementById('score');
const restartBtn = document.getElementById('restart');
let score = 0;
function setScore(v){ score = v; scoreEl.innerText = 'Score: ' + score; }

//// Game entities
// SK stands at left end, center of road
const roadY = () => canvas.height * 0.65;
const SK = {
  x: 110, // fixed near left
  y: () => roadY() - 10,
  w: 110,
  h: 48,
  swingAt: 0,
  swingDur: 300 // ms
};

// enemies: simple array; each with x,y,w,h,vx,label,alive,t
let enemies = [];

// spawn enemies from right edge moving left
function spawnEnemy(){
  const x = canvas.width + 60;
  const y = roadY() - (Math.random()*40 - 10); // around road line
  const w = 110, h = 46;
  const vx = - (1.2 + Math.random()*0.8 + Math.min(score/30, 1.5)); // speed increases slowly with score
  const labels = ['TEACHER','MADAM','SIR','MAM'];
  const label = labels[Math.floor(Math.random()*labels.length)];
  enemies.push({x,y,w,h,vx,label,alive:true,t:0});
}

// spawn initial enemies
for(let i=0;i<3;i++){
  // stagger spawn by pushing further right
  enemies.push({x: canvas.width + 60 + i*220, y: roadY() - (Math.random()*40 - 10), w:110,h:46, vx: -1.6, label: ['TEACHER','MADAM','SIR'][i%3], alive:true, t:0});
}

// input: detect tap/click on SK
function pointInSK(px,py){
  const sx = SK.x - SK.w/2;
  const sy = SK.y() - SK.h/2;
  return px >= sx && px <= sx + SK.w && py >= sy && py <= sy + SK.h;
}

canvas.addEventListener('click', (e)=>{
  const r = canvas.getBoundingClientRect();
  const px = e.clientX - r.left, py = e.clientY - r.top;
  if(pointInSK(px,py)) doSwing();
});
canvas.addEventListener('touchstart', (ev)=>{
  const t = ev.touches[0];
  const r = canvas.getBoundingClientRect();
  const px = t.clientX - r.left, py = t.clientY - r.top;
  if(pointInSK(px,py)) doSwing();
}, {passive:false});

// swing logic: if enemies within range (distance < rangeX and vertical close) then "prank" them
function doSwing(){
  const now = performance.now();
  if(SK.swingAt && now - SK.swingAt < SK.swingDur) return; // avoid spam
  SK.swingAt = now;
  // small click sound
  try{
    const A = new (window.AudioContext || window.webkitAudioContext)();
    const o = A.createOscillator(), g = A.createGain();
    o.type='sine'; o.frequency.value = 880; o.connect(g); g.connect(A.destination);
    o.start(); g.gain.exponentialRampToValueAtTime(0.00001, A.currentTime + 0.06);
  }catch(e){}
  // range check - enemies whose x is < SK.x + range and > SK.x
  const range = 170;
  for(let i=0;i<enemies.length;i++){
    const en = enemies[i];
    if(!en.alive) continue;
    const dx = en.x - SK.x;
    const dy = Math.abs(en.y - SK.y());
    if(dx < range && dx > -40 && dy < 60){
      // hit: mark pranked (non-violent vanish)
      en.alive = false;
      en.t = 0;
      spawnConfetti(en.x, en.y, 20);
      spawnPuff(en.x, en.y);
      setScore(score + 1);
    }
  }
}

// confetti & puff particles
let confetti = [], puffs = [];
function spawnConfetti(x,y,amount=18){
  const cols = ['#ffce00','#ff4d4d','#00ff9c','#00bfff','#d400ff'];
  for(let i=0;i<amount;i++){
    confetti.push({
      x, y,
      vx: (Math.random()-0.5)*6,
      vy: -3 - Math.random()*3,
      color: cols[Math.floor(Math.random()*cols.length)],
      size: 4+Math.random()*7,
      life: 700 + Math.random()*900,
      t:0
    });
  }
}
function spawnPuff(x,y){
  puffs.push({x,y,r:18+Math.random()*18,t:0,life:500});
}

// update loop
let last = performance.now();
function update(dt){
  // move enemies straight left
  for(let i=enemies.length-1;i>=0;i--){
    const en = enemies[i];
    if(en.alive){
      en.x += en.vx * (dt/16);
      en.t += dt;
      // if reach SK (go past), penalize a little and remove
      if(en.x < SK.x - 40){
        // they passed SK -> remove and spawn another
        enemies.splice(i,1);
        spawnEnemy();
        // optional penalty
        setScore(Math.max(0, score - 0));
      }
    } else {
      // dead: float up a bit and fade then remove
      en.y -= 0.4 * (dt/16);
      en.t += dt;
      if(en.t > 1200){
        enemies.splice(i,1);
        spawnEnemy();
      }
    }
  }

  // update confetti
  for(let i=confetti.length-1;i>=0;i--){
    const c = confetti[i];
    c.vy += 0.12 * (dt/16);
    c.x += c.vx * (dt/16);
    c.y += c.vy * (dt/16);
    c.t += dt;
    if(c.t > c.life) confetti.splice(i,1);
  }
  // update puffs
  for(let i=puffs.length-1;i>=0;i--){
    const p = puffs[i];
    p.t += dt;
    if(p.t > p.life) puffs.splice(i,1);
  }

  // ensure at least 3 enemies queued
  if(enemies.length < 3 && Math.random() < 0.03) spawnEnemy();
}

// render
function render(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // background (road)
  const ry = roadY();
  ctx.fillStyle = '#071226';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  // road strip
  ctx.fillStyle = '#0e1720';
  ctx.fillRect(0, ry, canvas.width, canvas.height - ry);
  ctx.fillStyle = '#ffd166';
  for(let i=0;i<canvas.width;i+=60) ctx.fillRect(i, ry + 44, 36, 6);

  // draw confetti
  for(const c of confetti){
    ctx.fillStyle = c.color;
    ctx.fillRect(c.x, c.y, c.size, c.size);
  }
  // draw puffs
  for(const p of puffs){
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,255,255,' + (0.65*(1 - p.t/p.life)) + ')';
    ctx.arc(p.x, p.y, p.r * (0.5 + p.t/p.life), 0, Math.PI*2);
    ctx.fill();
  }

  // draw enemies (moving right->left)
  for(const en of enemies){
    ctx.save();
    ctx.translate(en.x, en.y);
    // body
    ctx.fillStyle = en.alive ? '#ff6b6b' : '#8b8b8b';
    ctx.fillRect(-en.w/2, -en.h/2, en.w, en.h);
    // face circle
    ctx.beginPath(); ctx.fillStyle = '#fff'; ctx.arc(-en.w/2 + 20, -6, 10, 0, Math.PI*2); ctx.fill();
    // label text centered on rect
    ctx.fillStyle = '#111';
    ctx.font = '700 14px sans-serif';
    ctx.textAlign = 'center';
    const label = en.alive ? en.label : (en.prankedLabel || 'GONE');
    ctx.fillText(label, 0, 6);
    ctx.restore();
  }

  // draw SK at left end
  const sx = SK.x, sy = SK.y();
  ctx.fillStyle = '#00ff9c';
  ctx.fillRect(sx - SK.w/2, sy - SK.h/2, SK.w, SK.h);
  // stick icon (simple)
  ctx.fillStyle = '#6b3';
  ctx.fillRect(sx + SK.w/2 - 18, sy - 8, 10, 10);
  // SK label
  ctx.fillStyle = '#001';
  ctx.font = '800 18px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('SK', sx, sy + 6);

  // swing visual arc if swinging
  const now = performance.now();
  if(SK.swingAt && now - SK.swingAt < SK.swingDur){
    const prog = (now - SK.swingAt) / SK.swingDur;
    const alpha = 1 - prog;
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,' + alpha + ')';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.arc(sx + 20, sy - 10, 140, -Math.PI*0.9, -Math.PI*0.1);
    ctx.stroke();
    ctx.restore();
  }

  // UI score drawn by DOM too, but show top-left mini
  ctx.fillStyle = '#fff';
  ctx.font = '700 14px sans-serif';
  ctx.fillText('Score: ' + score, 14, 28);
}

// main loop
let last = performance.now();
function loop(now){
  const dt = now - last; last = now;
  update(dt);
  render();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// spawn helpers
function spawnInitial(n){
  enemies = [];
  for(let i=0;i<n;i++){
    enemies.push({x: canvas.width + 60 + i*180, y: roadY() - (Math.random()*40 - 10), w:110,h:46, vx: - (1.2 + Math.random()*0.8), label: ['TEACHER','MADAM','SIR'][i%3], alive:true, t:0});
  }
}
function spawnAll(){
  spawnEnemy();
}

// confetti & puff updates already handled in spawn functions

// restart handler
restartBtn.addEventListener('click', ()=>{ setScore(0); confetti=[]; puffs=[]; spawnInitial(3); });

// initialize
spawnInitial(3);
setScore(0);
</script>
</body>
</html>
