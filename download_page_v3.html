<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Sandbox Game</title>
    <style>
        /* CSS for basic styling */
        body {
            margin: 0;
            overflow: hidden; /* Hide scrollbars */
            background-color: #87ceeb; /* Sky Blue */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        /* The main game container/world */
        #game-container {
            position: relative;
            width: 800px;
            height: 600px;
            border: 2px solid black;
            overflow: hidden; /* To simulate camera view */
        }

        /* Player character style */
        #player {
            position: absolute;
            width: 32px;
            height: 64px; /* Tall character */
            background-color: black;
            z-index: 100;
            transition: top 0.05s linear, left 0.05s linear; /* Smooth movement visually */
        }

        /* Block (Tile) style */
        .tile {
            position: absolute;
            width: 32px;
            height: 32px;
            box-sizing: border-box;
            border: 1px solid rgba(0, 0, 0, 0.2);
        }

        .grass {
            background-color: #009600; /* Grass Green */
        }

        .dirt {
            background-color: #8b4513; /* Dirt Brown */
        }

        .brick {
            background-color: #964b00; /* Brick Brown */
        }

        /* UI Styles (Simplified Mobile Controls for Web) */
        #ui-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            gap: 10px;
            z-index: 200;
        }

        .ui-button {
            width: 60px;
            height: 60px;
            background-color: #555;
            color: white;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            cursor: pointer;
            user-select: none;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
        }
        
        /* Crosshair/Selection */
        #crosshair {
            position: absolute;
            width: 32px;
            height: 32px;
            border: 2px solid yellow;
            pointer-events: none; /* Allows clicks to pass through */
            z-index: 150;
        }

    </style>
</head>
<body>

<div id="game-container">
    <div id="player"></div>
    <div id="crosshair"></div>
</div>

<div id="ui-controls">
    <div class="ui-button" id="place-button">üß±</div> <div class="ui-button" id="dig-button">‚õèÔ∏è</div>   </div>

<script>
    // --- Game Configuration ---
    const TILE_SIZE = 32;
    const MAP_WIDTH = 50;
    const MAP_HEIGHT = 50;
    const CONTAINER_WIDTH = 800;
    const CONTAINER_HEIGHT = 600;

    // --- DOM Elements ---
    const gameContainer = document.getElementById('game-container');
    const playerElement = document.getElementById('player');
    const crosshairElement = document.getElementById('crosshair');
    const digButton = document.getElementById('dig-button');
    const placeButton = document.getElementById('place-button');

    // --- Game State ---
    let player = {
        x: (MAP_WIDTH / 2) * TILE_SIZE,
        y: (MAP_HEIGHT / 2) * TILE_SIZE - 64, // Start above the ground
        speed: 5
    };

    let camera = {
        x: 0,
        y: 0
    };

    let worldData = [];
    const blockTypes = {
        0: 'air',
        1: 'grass',
        2: 'dirt',
        3: 'brick'
    };

    // --- World Generation ---
    function generateWorld() {
        const surfaceLevel = MAP_HEIGHT / 2;
        for (let y = 0; y < MAP_HEIGHT; y++) {
            worldData[y] = [];
            for (let x = 0; x < MAP_WIDTH; x++) {
                if (y === surfaceLevel) {
                    worldData[y][x] = 1; // Grass
                } else if (y > surfaceLevel) {
                    worldData[y][x] = 2; // Dirt
                } else {
                    worldData[y][x] = 0; // Air
                }
            }
        }
    }

    // --- Rendering Functions ---
    function renderWorld() {
        // Clear old tiles (for simplicity, we re-render everything)
        // In a complex game, you'd only update visible tiles.
        const existingTiles = gameContainer.querySelectorAll('.tile');
        existingTiles.forEach(tile => tile.remove());

        for (let y = 0; y < MAP_HEIGHT; y++) {
            for (let x = 0; x < MAP_WIDTH; x++) {
                const blockId = worldData[y][x];
                if (blockId !== 0) {
                    const tileDiv = document.createElement('div');
                    tileDiv.classList.add('tile', blockTypes[blockId]);
                    tileDiv.style.left = `${x * TILE_SIZE}px`;
                    tileDiv.style.top = `${y * TILE_SIZE}px`;
                    tileDiv.dataset.x = x;
                    tileDiv.dataset.y = y;
                    gameContainer.appendChild(tileDiv);
                }
            }
        }
    }

    function updateCamera() {
        // Center the camera on the player
        camera.x = player.x - CONTAINER_WIDTH / 2 + playerElement.offsetWidth / 2;
        camera.y = player.y - CONTAINER_HEIGHT / 2 + playerElement.offsetHeight / 2;

        // Apply camera offset to the game container
        gameContainer.style.transform = `translate(${-camera.x}px, ${-camera.y}px)`;

        // Update player's position (relative to the container, before transform)
        playerElement.style.left = `${player.x}px`;
        playerElement.style.top = `${player.y}px`;
    }

    // --- Interaction Functions ---
    function getSelectedBlock() {
        // Crosshair is fixed at the center of the screen
        const crosshairCenterX = camera.x + CONTAINER_WIDTH / 2;
        const crosshairCenterY = camera.y + CONTAINER_HEIGHT / 2;

        const gridX = Math.floor(crosshairCenterX / TILE_SIZE);
        const gridY = Math.floor(crosshairCenterY / TILE_SIZE);
        
        // Update crosshair visual
        crosshairElement.style.left = `${gridX * TILE_SIZE}px`;
        crosshairElement.style.top = `${gridY * TILE_SIZE}px`;

        if (gridX >= 0 && gridX < MAP_WIDTH && gridY >= 0 && gridY < MAP_HEIGHT) {
            return { x: gridX, y: gridY };
        }
        return null;
    }

    function handleBlockAction(action) {
        const selected = getSelectedBlock();
        if (!selected) return;

        const { x, y } = selected;
        const currentBlock = worldData[y][x];
        
        // Check if the player is standing in the selected block's area
        const playerIsInBlock = (
            player.x < (x + 1) * TILE_SIZE &&
            player.x + TILE_SIZE > x * TILE_SIZE &&
            player.y < (y + 1) * TILE_SIZE &&
            player.y + 64 > y * TILE_SIZE
        );

        if (action === 'dig' && currentBlock !== 0 && !playerIsInBlock) {
            worldData[y][x] = 0; // Break block
            renderWorld();
        } else if (action === 'place' && currentBlock === 0) {
            // Place a Brick (ID 3)
            worldData[y][x] = 3; 
            renderWorld();
        }
    }

    // --- Movement Logic ---
    let keys = {};
    document.addEventListener('keydown', (e) => {
        keys[e.key] = true;
    });

    document.addEventListener('keyup', (e) => {
        keys[e.key] = false;
    });

    function updateMovement() {
        let dx = 0;
        let dy = 0;

        // Basic Movement (W/A/S/D or Arrow Keys)
        if (keys['ArrowLeft'] || keys['a']) dx -= player.speed;
        if (keys['ArrowRight'] || keys['d']) dx += player.speed;
        // NOTE: Vertical movement is simplified, gravity/jumping is needed for a true 2D sandbox game
        if (keys['ArrowUp'] || keys['w']) dy -= player.speed;
        if (keys['ArrowDown'] || keys['s']) dy += player.speed;

        // Apply movement
        player.x += dx;
        player.y += dy;

        // Simple boundary check
        player.x = Math.max(0, Math.min(player.x, MAP_WIDTH * TILE_SIZE - TILE_SIZE));
        player.y = Math.max(0, Math.min(player.y, MAP_HEIGHT * TILE_SIZE - 64));
    }


    // --- Game Loop (Main heartbeat) ---
    function gameLoop() {
        updateMovement();
        updateCamera();
        getSelectedBlock(); // Continuously update crosshair position

        requestAnimationFrame(gameLoop);
    }

    // --- Event Listeners for UI Buttons (Mobile Simulation) ---
    digButton.addEventListener('click', () => handleBlockAction('dig'));
    placeButton.addEventListener('click', () => handleBlockAction('place'));

    // --- Initialization ---
    generateWorld();
    renderWorld();
    gameLoop(); // Start the loop

</script>
</body>
    </html>
